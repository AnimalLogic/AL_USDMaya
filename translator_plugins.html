<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>AL_USDMaya: Custom Plugin Translators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">AL_USDMaya
   &#160;<span id="projectnumber">0.29.4</span>
   </div>
   <div id="projectbrief">USD to Maya Bridge</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('translator_plugins.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Custom Plugin Translators </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The plug-in translator system that is the core of AL_USDMaya provides a number of ways to integrate USD with existing maya nodes (including custom Maya plug-ins). Any particular type can be integrated in one (or all) of these ways:</p>
<p>File Import File Export Importing as part of an AL_usdmaya_ProxyShape Handling the changes to a AL_usdmaya_ProxyShape as a result of a variant switch</p>
<p>The API for defining your own plug-in translator may at first seems a little convoluted (especially if you were expecting to override a pair of import/export methods), however this API has evolved over time to ensure it works correctly with live variant switches, prim activation/de-activation, and a number of other live changes to the underlying USD scene.</p>
<p>To try to explain how this all works, let's start of with an extremely silly plug-in example that will create a custom translator plugin to represent a polygon cube node in Maya.</p>
<p>PolyCubeNodeTranslator.h* </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;AL/usdmaya/fileio/translators/TranslatorBase.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;AL/usdmaya/fileio/translators/TranslatorContext.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>PolyCubeNodeTranslator</div>
<div class="line">  : <span class="keyword">public</span> <a class="code" href="classAL_1_1usdmaya_1_1fileio_1_1translators_1_1TranslatorBase.html">AL::usdmaya::fileio::translators::TranslatorBase</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">  <a class="code" href="group__translators.html#gaa2ebd02f43bdd2c990c6b456969947f6">AL_USDMAYA_DECLARE_TRANSLATOR</a>(PolyCubeNodeTranslator);</div>
<div class="line"></div>
<div class="line">  MStatus <a class="code" href="classAL_1_1usdmaya_1_1fileio_1_1translators_1_1TranslatorAbstract.html#a87addd157908093085f8875cda7cf76d">initialize</a>() <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code" href="classAL_1_1usdmaya_1_1fileio_1_1translators_1_1TranslatorAbstract.html#a8eb1c35a619354479dcb3ebb3e3129f9">needsTransformParent</a>() <span class="keyword">override</span>;</div>
<div class="line">  MStatus writeEdits(MObject node, <span class="keyword">const</span> UsdPrim&amp; prim); </div>
<div class="line">  MStatus <span class="keyword">import</span>(<span class="keyword">const</span> UsdPrim&amp; prim, MObject&amp; parent) <span class="keyword">override</span>;</div>
<div class="line">  MStatus <a class="code" href="classAL_1_1usdmaya_1_1fileio_1_1translators_1_1TranslatorAbstract.html#a11ada18c09e42da28d1b93274ffc62ab">postImport</a>(<span class="keyword">const</span> UsdPrim&amp; prim) <span class="keyword">override</span>;</div>
<div class="line">  MStatus <a class="code" href="classAL_1_1usdmaya_1_1fileio_1_1translators_1_1TranslatorAbstract.html#a70fbb32eb8ed8638ab872f1d0b0ae4c6">preTearDown</a>(<span class="keyword">const</span> UsdPrim&amp; prim) <span class="keyword">override</span>;</div>
<div class="line">  MStatus <a class="code" href="classAL_1_1usdmaya_1_1fileio_1_1translators_1_1TranslatorAbstract.html#aece51923822ab802b9c49c9d2d5e3e4e">update</a>(<span class="keyword">const</span> UsdPrim&amp; prim) <span class="keyword">override</span>;</div>
<div class="line">  MStatus <a class="code" href="classAL_1_1usdmaya_1_1fileio_1_1translators_1_1TranslatorAbstract.html#a9f886a9e776819ef7f235a75e587bf26">tearDown</a>(<span class="keyword">const</span> SdfPath&amp; primPath) <span class="keyword">override</span>;</div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code" href="classAL_1_1usdmaya_1_1fileio_1_1translators_1_1TranslatorAbstract.html#a4791276fb35ce48c60dd362c2f52fa3d">supportsUpdate</a>() <span class="keyword">const override</span>;</div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code" href="classAL_1_1usdmaya_1_1fileio_1_1translators_1_1TranslatorAbstract.html#a6f81d9cd3b7704f31164588c6dab205d">importableByDefault</a>() <span class="keyword">const override</span>;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// new to AL_USDMaya 0.29.0</span></div>
<div class="line">  ExportFlag <a class="code" href="classAL_1_1usdmaya_1_1fileio_1_1translators_1_1TranslatorAbstract.html#ac1215b306bc653be6002f33f0d904ed9">canExport</a>(<span class="keyword">const</span> MObject&amp; obj) <span class="keyword">override</span>;</div>
<div class="line">  UsdPrim exportObject(UsdStageRefPtr stage, MDagPath dagPath, <span class="keyword">const</span> SdfPath&amp; usdPath, <span class="keyword">const</span> ExporterParams&amp; params) <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"></div>
<div class="line">  <span class="comment">// handles to the polycube attributes</span></div>
<div class="line">  MObject m_width;</div>
<div class="line">  MObject m_height;</div>
<div class="line">  MObject m_depth;</div>
<div class="line">  MObject m_subdivisionsWidth;</div>
<div class="line">  MObject m_subdivisionsHeight;</div>
<div class="line">  MObject m_subdivisionsDepth;</div>
<div class="line">  MObject m_outputMesh;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// handles to the mesh attributes</span></div>
<div class="line">  MObject m_inputMesh;</div>
<div class="line">};</div>
</div><!-- fragment --><p>As an absolute minimum, you'll need to implement the update and tearDown methods. The following is an explanation of what those methods do, and how to implement them correctly.</p>
<p><b>General</b> <b>Setup</b> </p>
<p>PolyCubeNodeTranslator.cpp* </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;PolyCubeNodeTranslator.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;AL/usd/schemas/PolyCube.h&quot;</span>  <span class="comment">//&lt; this is the custom schema you have created</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Some macro magic that generates some boiler plate code.</span></div>
<div class="line"><a class="code" href="group__translators.html#gad4cc30c4cde0e2dccd6c4d4d3283165f">AL_USDMAYA_DEFINE_TRANSLATOR</a>(PolyCubeNodeTranslator, AL_usd_PolyCube);</div>
</div><!-- fragment --><p><b>initialize</b> </p>
<p>The initialize method is a one time initialisation step for your translator plug-in. Now we all want to ensure our plug-ins operate as quickly as possible right? So the initialize step is really to help improve the performance when accessing data via MPlugs (i.e. Ideally we don't want to be accessing MPlugs by constantly calling findPlug("someString"))</p>
<div class="fragment"><div class="line">MStatus PolyCubeNodeTranslator::initialize()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// If you need to load any plugins at this point, feel free!</span></div>
<div class="line">  <span class="comment">// Luckily we don&#39;t need to load a plug-in for our poly cube.</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="comment">// assign a node class to the polyCube</span></div>
<div class="line">  MNodeClass polyCube(<span class="stringliteral">&quot;polyCube&quot;</span>);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// now do a one time look up of the attributes. This now means we can access the attributes directly</span></div>
<div class="line">  <span class="comment">// without needing to call MFnDependencyNode::findPlug() (and the string compares that implies!)</span></div>
<div class="line">  m_width = polyCube.attribute(<span class="stringliteral">&quot;width&quot;</span>);</div>
<div class="line">  m_height = polyCube.attribute(<span class="stringliteral">&quot;height&quot;</span>);</div>
<div class="line">  m_depth = polyCube.attribute(<span class="stringliteral">&quot;depth&quot;</span>);</div>
<div class="line">  m_subdivisionsWidth = polyCube.attribute(<span class="stringliteral">&quot;subdivisionsWidth&quot;</span>);</div>
<div class="line">  m_subdivisionsHeight = polyCube.attribute(<span class="stringliteral">&quot;subdivisionsHeight&quot;</span>);</div>
<div class="line">  m_subdivisionsDepth = polyCube.attribute(<span class="stringliteral">&quot;subdivisionsDepth&quot;</span>);</div>
<div class="line">  m_outputMesh = polyCube.attribute(<span class="stringliteral">&quot;output&quot;</span>);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// assign a node class to mesh</span></div>
<div class="line">  MNodeClass mesh(<span class="stringliteral">&quot;mesh&quot;</span>);</div>
<div class="line">  m_inputMesh = mesh.attribute(<span class="stringliteral">&quot;input&quot;</span>);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Now obviously you&#39;re a careful developer, and have been checking all MStatus values in the code above right???</span></div>
<div class="line">  <span class="comment">// Just returning success isn&#39;t something we&#39;re advocating here, it&#39;s just a silly tutorial after all!</span></div>
<div class="line">  <span class="keywordflow">return</span> MS::kSuccess;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>needsTransformParent</b> </p>
<p>One function you may want to overload is the needsTransformParent() function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> PolyCubeNodeTranslator::needsTransformParent()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>If your node is a DAG node (i.e. a shape or custom transform), it will need to have a transform created for it, so return true in this case. If however you node is a simple DG node (e.g. surface shader, texture etc), then you should return false from this method.</p>
<p>If you return true, a new transform will be generated within Maya to which you can parent your shape on creation. If you return false, no transform will be generated.</p>
<p><b>import</b> </p>
<p>The Import method should only <em>really</em> be used to create the Maya nodes that will represent your custom prim. Now there is a small caveat to this. If the contents of your prim does not have any relationships to other prims in the stage, then you may as well do all of the setup you need within Import.</p>
<p>This example will create a simple polyCubeCreator node, a mesh, and connect them together. To do this will not require information from any other prim (for example, if there was another prim that contained a surface material, or a mesh deformation, then there would be a second step involved here to make those relationships in the Maya DG).</p>
<div class="fragment"><div class="line">MStatus PolyCubeNodeTranslator::import(<span class="keyword">const</span> UsdPrim&amp; prim, MObject&amp; parent)</div>
<div class="line">{</div>
<div class="line">  MFnDependencyNode fnDep;</div>
<div class="line">  MFnDagNode fnDag;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// create the two maya nodes we need (parent the shape under the transform node that&#39;s been created for us)</span></div>
<div class="line">  MObject oPolyCube = fnDep.createNode();</div>
<div class="line">  MObject oMesh = fnDag.createNode(<span class="stringliteral">&quot;mesh&quot;</span>, parent);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// we need to register the nodes we create with the</span></div>
<div class="line">  context()-&gt;insertItem(prim.GetPath(), oPolyCube);</div>
<div class="line">  context()-&gt;insertItem(prim.GetPath(), oMesh);</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">float</span> width = 1.0f;</div>
<div class="line">  <span class="keywordtype">float</span> height = 1.0f;</div>
<div class="line">  <span class="keywordtype">float</span> depth = 1.0f;</div>
<div class="line">  int32_t subdivisionsWidth = 1;</div>
<div class="line">  int32_t subdivisionsHeight = 1;</div>
<div class="line">  int32_t subdivisionsDepth = 1;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Now gather the parameters from the schema node</span></div>
<div class="line">  AL_usd_PolyCube schema(prim);</div>
<div class="line">  <span class="keywordflow">if</span>(<span class="keyword">auto</span> attr = schema.GetWidthAttr()) attr.Get(&amp;width);</div>
<div class="line">  <span class="keywordflow">if</span>(<span class="keyword">auto</span> attr = schema.GetHeightAttr()) attr.Get(&amp;height);</div>
<div class="line">  <span class="keywordflow">if</span>(<span class="keyword">auto</span> attr = schema.GetDepthAttr()) attr.Get(&amp;depth);</div>
<div class="line">  <span class="keywordflow">if</span>(<span class="keyword">auto</span> attr = schema.GetSubdivisionsWidthAttr()) attr.Get(&amp;subdivisionsWidth);</div>
<div class="line">  <span class="keywordflow">if</span>(<span class="keyword">auto</span> attr = schema.GetSubdivisionsHeightAttr()) attr.Get(&amp;subdivisionsHeight);</div>
<div class="line">  <span class="keywordflow">if</span>(<span class="keyword">auto</span> attr = schema.GetSubdivisionsDepthAttr()) attr.Get(&amp;subdivisionsDepth);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// set the values on the poly cube creator node</span></div>
<div class="line">  MPlug(oPolyCube, m_width).setValue(width);</div>
<div class="line">  MPlug(oPolyCube, m_height).setValue(height);</div>
<div class="line">  MPlug(oPolyCube, m_depth).setValue(depth);</div>
<div class="line">  MPlug(oPolyCube, m_subdivisionsWidth).setValue(subdivisionsWidth);</div>
<div class="line">  MPlug(oPolyCube, m_subdivisionsHeight).setValue(subdivisionsHeight);</div>
<div class="line">  MPlug(oPolyCube, m_subdivisionsDepth).setValue(subdivisionsDepth);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// please check errors, and don&#39;t just return success! :)</span></div>
<div class="line">  <span class="keywordflow">return</span> MS::kSuccess;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Post</b> <b>Import</b> </p>
<p>Having generated all of the nodes you need to, you might end up needing to hook those nodes to other prims. This is admittedly a bit of a bad example (because in this case the node connections could have all been made within import itself).</p>
<p>However, in cases where the scene involves relationships between prims (e.g. one prim is a material, the other is the shape), it won't be possible to make those connections within import (because the other Maya node may not have been created yet). In those cases, you will need to make use of the postImport method to perform the connection of the maya nodes to other prims.</p>
<div class="fragment"><div class="line">MStatus PolyCubeNodeTranslator::postImport(<span class="keyword">const</span> UsdPrim&amp; inputPrim, MObject&amp; parent)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Previously we created two Maya nodes for our inputPrim (the mesh and the polycube).</span></div>
<div class="line">  <span class="comment">// Whenever you need to retrieve those Maya nodes, you can retrieve them from the translator context</span></div>
<div class="line">  <span class="comment">// by passing the prim, and the type of node you are searching for, into the getMObject function.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// If you have a situation where your inputPrim has a relationship to another prim (e.g. the other prim</span></div>
<div class="line">  <span class="comment">// may be a surface material, geometry deformer, etc), and you wish to extract the MObject for that related</span></div>
<div class="line">  <span class="comment">// prim, then just pass the related prim in as the first argument, and it will be returned to you.</span></div>
<div class="line"></div>
<div class="line">  MObjectHandle handleToMesh;</div>
<div class="line">  <span class="keywordflow">if</span>(!context()-&gt;getMObject(inputPrim, handleToMesh, MFn::kMesh))</div>
<div class="line">  {</div>
<div class="line">    MGlobal::displayError(<span class="stringliteral">&quot;unable to locate mesh&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> MS::kFailure;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  MObjectHandle handleToPolyCube;</div>
<div class="line">  <span class="keywordflow">if</span>(!context()-&gt;getMObject(inputPrim, handleToPolyCube, MFn::kPolyCube))</div>
<div class="line">  {</div>
<div class="line">    MGlobal::displayError(<span class="stringliteral">&quot;unable to locate polycube&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> MS::kFailure;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// now connect the output of the polycube to the input of the mesh.</span></div>
<div class="line">  MDGModifier mod;</div>
<div class="line">  mod.connect(MPlug(handleToPolyCube.object(), m_outputMesh), MPlug(handleToMesh.object(), m_inputMesh));</div>
<div class="line">  mod.doIt();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// please check and log any errors rather than simply returning success!</span></div>
<div class="line">  <span class="keywordflow">return</span> MS::kSuccess;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Variant</b> <b>Switching</b> </p>
<p>If you've only supported the methods previously discussed, then your custom prim type should now be imported when you load a usd scene with the proxy shape.</p>
<p>If however you want to be able to respond to variant switches, and swap in or out nodes as a result, there is a little bit more work to do.</p>
<p>When a variant is switched, the proxy shape intercepts an event generated by USD that indicates that a variant is about to switch on a specific prim. At this point, the <a class="elRef" doxygen="/film/tools/packages/shareBase/11.1.46/CentOS-6.9_thru_8/AL_boost-1.55.0/doc/shareBase.tag:http://github.al.com.au/pages/documentation/shareBase/" href="http://github.al.com.au/pages/documentation/shareBase/namespaceAL.html">AL</a> maya plugin will traverse the hierarchy under the prim on which the variant switched, and call a preTearDown() method. This method can be used to copy any values from your maya nodes into a layer within the usd stage.</p>
<div class="fragment"><div class="line"><span class="comment">// This is just a helper method (to avoid some code duplication later on)</span></div>
<div class="line"><span class="comment">// It simply reads the node values from Maya, and sets writes those values</span></div>
<div class="line"><span class="comment">// to the USD file</span></div>
<div class="line">MStatus PolyCubeNodeTranslator::writeEdits(MObject oPolyCube, UsdPrim&amp; prim)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">float</span> width = 1.0f;</div>
<div class="line">  <span class="keywordtype">float</span> height = 1.0f;</div>
<div class="line">  <span class="keywordtype">float</span> depth = 1.0f;</div>
<div class="line">  int32_t subdivisionsWidth = 1;</div>
<div class="line">  int32_t subdivisionsHeight = 1;</div>
<div class="line">  int32_t subdivisionsDepth = 1;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// get the values from the poly cube creator node</span></div>
<div class="line">  MPlug(oPolyCube, m_width).getValue(width);</div>
<div class="line">  MPlug(oPolyCube, m_height).getValue(height);</div>
<div class="line">  MPlug(oPolyCube, m_depth).getValue(depth);</div>
<div class="line">  MPlug(oPolyCube, m_subdivisionsWidth).getValue(subdivisionsWidth);</div>
<div class="line">  MPlug(oPolyCube, m_subdivisionsHeight).getValue(subdivisionsHeight);</div>
<div class="line">  MPlug(oPolyCube, m_subdivisionsDepth).getValue(subdivisionsDepth);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Now set the parameters on the schema node (if they differ from the defaults)</span></div>
<div class="line">  AL_usd_PolyCube schema(prim);</div>
<div class="line">  <span class="keywordflow">if</span>(width != 1.0f) schema.CreateWidthAttr().Set(width);</div>
<div class="line">  <span class="keywordflow">if</span>(height != 1.0f) schema.CreateHeightAttr().Set(height);</div>
<div class="line">  <span class="keywordflow">if</span>(depth != 1.0f) schema.CreateDepthAttr().Set(depth);</div>
<div class="line">  <span class="keywordflow">if</span>(subdivisionsWidth != 1) schema.CreateSubdivisionsWidthAttr().Set(subdivisionsWidth);</div>
<div class="line">  <span class="keywordflow">if</span>(subdivisionsHeight != 1) schema.CreateSubdivisionsHeightAttr().Set(subdivisionsHeight);</div>
<div class="line">  <span class="keywordflow">if</span>(subdivisionsDepth != 1) schema.CreateSubdivisionsDepthAttr().Set(subdivisionsDepth);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// please check errors, and don&#39;t just return success! :)</span></div>
<div class="line">  <span class="keywordflow">return</span> MS::kSuccess;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// This method is called prior to a variant switch occurring (that may destroy our node)</span></div>
<div class="line">MStatus PolyCubeNodeTranslator::preTearDown(UsdPrim&amp; prim)</div>
<div class="line">{</div>
<div class="line">  MObjectHandle handleToPolyCube;</div>
<div class="line">  <span class="keywordflow">if</span>(!context()-&gt;getMObject(prim, handleToPolyCube, MFn::kPolyCube))</div>
<div class="line">  {</div>
<div class="line">    MGlobal::displayError(<span class="stringliteral">&quot;unable to locate polycube&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> MS::kFailure;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> writeEdits(handleToPolyCube.object(), prim);</div>
<div class="line">}</div>
</div><!-- fragment --><p>After the variant switch has occurred, the <a class="elRef" doxygen="/film/tools/packages/shareBase/11.1.46/CentOS-6.9_thru_8/AL_boost-1.55.0/doc/shareBase.tag:http://github.al.com.au/pages/documentation/shareBase/" href="http://github.al.com.au/pages/documentation/shareBase/namespaceAL.html">AL</a> USD plugin will do a quick sanity check comparing the prims that were there previously, and the ones that are there now.</p>
<p>For each prim, if a corresponding prim still exists after the variant switch, AND the prim type is the same, then it call an update() method on your translator. Adding this method is optional, however it can improve the speed of a variant switch, so it is recommended!</p>
<p>If you wish to provide an update method to your translator, you will first need to opt in to this mechanism. By returning true from supportsUpdate (by default it returns false), you will now be able to provide a slightly quicker way for handling prims that do not change as a result of the switch. If however you return false here, your node will always be destroyed (via tear down), before being re-imported.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> PolyCubeNodeTranslator::supportsUpdate()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Once you have notified <a class="elRef" doxygen="/film/tools/packages/shareBase/11.1.46/CentOS-6.9_thru_8/AL_boost-1.55.0/doc/shareBase.tag:http://github.al.com.au/pages/documentation/shareBase/" href="http://github.al.com.au/pages/documentation/shareBase/namespaceAL.html">AL</a> usd maya that your translator can update, simply provide your update function (which should simply copy the values from the prim and onto the maya nodes you previously created)</p>
<div class="fragment"><div class="line">MStatus PolyCubeNodeTranslator::update(<span class="keyword">const</span> UsdPrim&amp; prim)</div>
<div class="line">{</div>
<div class="line">  MObjectHandle handleToPolyCube;</div>
<div class="line">  <span class="keywordflow">if</span>(!context()-&gt;getMObject(prim, handleToPolyCube, MFn::kPolyCube))</div>
<div class="line">  {</div>
<div class="line">    MGlobal::displayError(<span class="stringliteral">&quot;unable to locate polycube&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> MS::kFailure;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  MObject oPolyCube = handleToPolyCube.object();</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">float</span> width = 1.0f;</div>
<div class="line">  <span class="keywordtype">float</span> height = 1.0f;</div>
<div class="line">  <span class="keywordtype">float</span> depth = 1.0f;</div>
<div class="line">  int32_t subdivisionsWidth = 1;</div>
<div class="line">  int32_t subdivisionsHeight = 1;</div>
<div class="line">  int32_t subdivisionsDepth = 1;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Now gather the parameters from the schema node</span></div>
<div class="line">  AL_usd_PolyCube schema(prim);</div>
<div class="line">  <span class="keywordflow">if</span>(<span class="keyword">auto</span> attr = schema.GetWidthAttr()) attr.Get(&amp;width);</div>
<div class="line">  <span class="keywordflow">if</span>(<span class="keyword">auto</span> attr = schema.GetHeightAttr()) attr.Get(&amp;height);</div>
<div class="line">  <span class="keywordflow">if</span>(<span class="keyword">auto</span> attr = schema.GetDepthAttr()) attr.Get(&amp;depth);</div>
<div class="line">  <span class="keywordflow">if</span>(<span class="keyword">auto</span> attr = schema.GetSubdivisionsWidthAttr()) attr.Get(&amp;subdivisionsWidth);</div>
<div class="line">  <span class="keywordflow">if</span>(<span class="keyword">auto</span> attr = schema.GetSubdivisionsHeightAttr()) attr.Get(&amp;subdivisionsHeight);</div>
<div class="line">  <span class="keywordflow">if</span>(<span class="keyword">auto</span> attr = schema.GetSubdivisionsDepthAttr()) attr.Get(&amp;subdivisionsDepth);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// set the values on the poly cube creator node</span></div>
<div class="line">  MPlug(oPolyCube, m_width).setValue(width);</div>
<div class="line">  MPlug(oPolyCube, m_height).setValue(height);</div>
<div class="line">  MPlug(oPolyCube, m_depth).setValue(depth);</div>
<div class="line">  MPlug(oPolyCube, m_subdivisionsWidth).setValue(subdivisionsWidth);</div>
<div class="line">  MPlug(oPolyCube, m_subdivisionsHeight).setValue(subdivisionsHeight);</div>
<div class="line">  MPlug(oPolyCube, m_subdivisionsDepth).setValue(subdivisionsDepth);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// please check errors, and don&#39;t just return success! :)</span></div>
<div class="line">  <span class="keywordflow">return</span> MS::kSuccess;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now the eagle eyed reader may notice that the above function looks very similar to the import() function we initially wrote. To save yourself from a boiler plate code explosion, one option would be to simply call update from import:</p>
<div class="fragment"><div class="line">MStatus PolyCubeNodeTranslator::import(<span class="keyword">const</span> UsdPrim&amp; prim, MObject&amp; parent)</div>
<div class="line">{</div>
<div class="line">  MFnDependencyNode fnDep;</div>
<div class="line">  MFnDagNode fnDag;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// create the two maya nodes we need (parent the shape under the transform node that&#39;s been created for us)</span></div>
<div class="line">  MObject oPolyCube = fnDep.createNode();</div>
<div class="line">  MObject oMesh = fnDag.createNode(<span class="stringliteral">&quot;mesh&quot;</span>, parent);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// we need to register the nodes we create with the</span></div>
<div class="line">  context()-&gt;insertItem(prim.GetPath(), oPolyCube);</div>
<div class="line">  context()-&gt;insertItem(prim.GetPath(), oMesh);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Just call update to set the parameters!</span></div>
<div class="line">  <span class="keywordflow">return</span> update(prim);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, if the variant switch results in the prim type changing, or the prim being removed, then a final method will be called, which is tearDown. The simplest implementation of this method is the following:</p>
<div class="fragment"><div class="line">MStatus PolyCubeNodeTranslator::tearDown(<span class="keyword">const</span> SdfPath&amp; primPath)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// delete all the maya nodes currently associated with the prim path</span></div>
<div class="line">  context()-&gt;removeItems(primPath);</div>
<div class="line">  <span class="keywordflow">return</span> MStatus::kSuccess;</div>
<div class="line">}</div>
</div><!-- fragment --><p>In most cases that is probably enough. In some cases however, there may be times when you need to ensure the nodes are deleted in a specific order, or you have some other book keeping exercise to perform. Feel free to do so here!</p>
<p>It should be noted that whilst preTearDown and update are optional, tearDown is NOT. You must implement this method in order to support variant switching!</p>
<p><b>Importable</b> <b>by</b> <b>Default</b> </p>
<p>When a USD file is imported into a proxy shape node, if you <em>always</em> want that node to be imported immediately, then you should return true from the importableByDefault method (which is the default). This will cause the translator to be run as soon as the matching prim type has been encountered. In some cases, you might not want those prims to be immediately imported. One example of this is with mesh data.</p>
<p>If you are importing a very geometry heavy scene with a large number of dense meshes, you would want to keep those meshes within USD/Hydra for as long as possible for performance reasons. If you return false from importableByDefault, then that particular node type can only be manually imported by calling the AL_usdmaya_TranslatePrim command. This means that importing and displaying the data will be quick by default, however if you need to make modifications to that particular prim, you'll be able to selectively import the data when needed.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> PolyCubeNodeTranslator::importableByDefault()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>canExport</b> </p>
<p>If you wish to provide support for the standard file export operations (e.g. export some Maya data as a USD file), then there is a two step process you need to adhere to. The first step is to determine whether this translator can handle the export of a given Maya node, and the second step is to implement the actual export of that data.</p>
<div class="fragment"><div class="line">ExportFlag PolyCubeNodeTranslator::canExport(<span class="keyword">const</span> MObject&amp; obj)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// test to see if we have a mesh object</span></div>
<div class="line">  <span class="keywordflow">if</span>(obj.hasFn(MFn::kMesh))</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// check the &#39;input&#39; attr to see if it connected to a polyCube node</span></div>
<div class="line">    MPlug input(obj, m_inputMesh);</div>
<div class="line">    MPlugArray plugs;</div>
<div class="line">    input.connectedTo(plugs, <span class="keyword">true</span>, <span class="keyword">false</span>);</div>
<div class="line">    <span class="keywordflow">if</span>(plugs.length() &gt; 0 &amp;&amp; plugs[0].node().hasFn(MFn::kPolyCube))</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// If it is, return &#39;kSupported&#39;. By default, all translators shipped</span></div>
<div class="line">      <span class="comment">// with the OSS build of AL_USDMaya return &#39;kFallbackSupport&#39; if supported.</span></div>
<div class="line">      <span class="comment">// kSupported always takes precedence over kFallbackSupport, which means</span></div>
<div class="line">      <span class="comment">// you can override the default support without your studio.</span></div>
<div class="line">      <span class="keywordflow">return</span> ExportFlag::kSupported;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> ExportFlag::kNotSupported;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>exportObject</b> </p>
<p>Finally, if the object can be exported by your translator, and it is the best translator available, then AL_USDMaya will call the exportObject method to export the data into USD. It's worth noting that the preTearDown and exportObject methods are likely to share a significant amount of code, hence the reason for utilising a common 'writeEdits' method.</p>
<div class="fragment"><div class="line">UsdPrim PolyCubeNodeTranslator::exportObject(</div>
<div class="line">  UsdStageRefPtr stage,</div>
<div class="line">  MDagPath dagPath,</div>
<div class="line">  <span class="keyword">const</span> SdfPath&amp; usdPath,</div>
<div class="line">  <span class="keyword">const</span> ExporterParams&amp; params)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// check the &#39;input&#39; attr to see if it connected to a polyCube node</span></div>
<div class="line">  MPlug input(dagPath.node(), m_inputMesh);</div>
<div class="line">  MPlugArray plugs;</div>
<div class="line">  input.connectedTo(plugs, <span class="keyword">true</span>, <span class="keyword">false</span>);</div>
<div class="line">  <span class="keywordflow">if</span>(plugs.length() &gt; 0 &amp;&amp; plugs[0].node().hasFn(MFn::kPolyCube))</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// create the new USD prim</span></div>
<div class="line">    AL_usd_PolyCube cube = AL_usd_PolyCube::Define(stage, usdPath);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// copy values into the cube prim</span></div>
<div class="line">    writeEdits(plugs[0].node(), cube.GetPrim());</div>
<div class="line">    <span class="keywordflow">return</span> cube.GetPrim();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> UsdPrim();</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Nov 2 2018 11:40:20 for AL_USDMaya by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
